<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title data-i18n="inbound_title">입고 작업 - 이화 - 서한 시스템</title>
    
    <!-- Supabase 클라이언트 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- i18n 스크립트 -->
    <script src="../js/i18n.js"></script>
    
    <!-- Supabase 설정 -->
    <script src="../js/config.js"></script>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- 키보드 숨김 기능 -->
    <script>
        // 강화된 키보드 숨김 함수
        function hideKeyboard() {
            // 1. 모든 입력 필드에서 포커스 제거
            const inputs = document.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                input.blur();
                input.setAttribute('readonly', 'readonly');
                input.setAttribute('tabindex', '-1');
                setTimeout(() => {
                    input.removeAttribute('readonly');
                    input.removeAttribute('tabindex');
                }, 100);
            });
            
            // 2. 화면을 터치하여 키보드 숨김
            document.body.click();
            
            // 3. 모바일에서 키보드 숨김을 위한 추가 처리
            if (window.scrollTo) {
                window.scrollTo(0, 0);
            }
            
            // 4. 가상 키보드 숨김을 위한 추가 처리
            document.activeElement && document.activeElement.blur();
            
            // 5. 포커스를 body로 이동
            document.body.focus();
            
            // 6. 입력 필드 비활성화 후 재활성화
            inputs.forEach(input => {
                input.disabled = true;
                setTimeout(() => {
                    input.disabled = false;
                }, 50);
            });
        }
        
        // 입력 필드 포커스 방지 함수 (입고 작업 시에는 사용하지 않음 - 키보드 활성화)
        function preventInputFocus() {
            // 입고 작업 시에는 키보드를 활성화하므로 이 함수는 사용하지 않음
            // 바코드 입력 필드는 항상 활성화
            return;
        }
        
        // 바코드 입력 필드 특별 처리 (입고 작업 시 키보드 비활성화)
        function setupBarcodeInput() {
            const barcodeInput = document.getElementById('barcodeInput');
            if (barcodeInput) {
                // 입고 작업 시에는 바코드 스캐너를 사용하므로 키보드 비활성화
                // 포커스는 허용하되 키보드는 나타나지 않도록 설정
                barcodeInput.setAttribute('readonly', 'readonly');
                barcodeInput.setAttribute('inputmode', 'none');
                
                // 포커스 시에도 키보드가 나타나지 않도록 처리
                barcodeInput.addEventListener('focus', function() {
                    // readonly 유지하여 키보드 비활성화
                    this.setAttribute('readonly', 'readonly');
                    this.setAttribute('inputmode', 'none');
                });
                
                // 클릭/터치 시에도 키보드가 나타나지 않도록
                barcodeInput.addEventListener('click', function(e) {
                    e.preventDefault();
                    this.focus();
                    this.select();
                });
                
                barcodeInput.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    this.focus();
                    this.select();
                });
                
                // 바코드 입력 필드 포커스는 허용하되 키보드는 비활성화
                // (스캔을 위해 포커스 제어하지 않음, 하지만 키보드는 나타나지 않음)
            }
        }
        
        // 페이지 로드 시 바코드 입력 필드 설정 (입고 작업 시 키보드 활성화)
        document.addEventListener('DOMContentLoaded', function() {
            // 입고 작업 시에는 키보드를 활성화하므로 hideKeyboard 호출 제거
            setTimeout(setupBarcodeInput, 300);
        });
        
        // 입고 작업 시에는 키보드를 활성화하므로 화면 터치 시 키보드 숨김 기능 제거
        // (바코드 입력 필드에 포커스가 있을 때는 키보드 유지)
    </script>
    
    <script>
        // Tailwind 설정은 CDN 로드 후에 실행
        function configureTailwind() {
            if (window.tailwind) {
                tailwind.config = {
                    theme: {
                        extend: {
                            colors: {
                                primary: '#3B82F6',
                                secondary: '#64748B',
                                success: '#10B981',
                                warning: '#F59E0B',
                                danger: '#EF4444'
                            },
                            animation: {
                                'fade-in': 'fadeIn 0.5s ease-in-out',
                                'slide-up': 'slideUp 0.5s ease-out',
                                'bounce-in': 'bounceIn 0.6s ease-out',
                                'float': 'float 3s ease-in-out infinite',
                                'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite'
                            },
                            keyframes: {
                                fadeIn: {
                                    '0%': { opacity: '0' },
                                    '100%': { opacity: '1' }
                                },
                                slideUp: {
                                    '0%': { transform: 'translateY(20px)', opacity: '0' },
                                    '100%': { transform: 'translateY(0)', opacity: '1' }
                                },
                                bounceIn: {
                                    '0%': { transform: 'scale(0.3)', opacity: '0' },
                                    '50%': { transform: 'scale(1.05)' },
                                    '70%': { transform: 'scale(0.9)' },
                                    '100%': { transform: 'scale(1)', opacity: '1' }
                                },
                                float: {
                                    '0%, 100%': { transform: 'translateY(0px)' },
                                    '50%': { transform: 'translateY(-10px)' }
                                }
                            }
                        }
                    }
                }
            } else {
                // CDN이 아직 로드되지 않았다면 잠시 후 다시 시도
                setTimeout(configureTailwind, 100);
            }
        }
        
        // 페이지 로드 시 Tailwind 설정
        document.addEventListener('DOMContentLoaded', configureTailwind);
    </script>
    <style>
        /* PDA 최적화 스타일 */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .action-button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            border: none;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .action-button:active::before {
            left: 100%;
        }
        
        .action-button:active {
            transform: scale(0.98);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        .cancel-btn {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .dropdown-select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            background: white;
            transition: all 0.3s ease;
        }
        
        .dropdown-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .scan-input {
            width: 100%;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 18px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
        }
        
        .scan-input:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }
        
        .main-menu-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            border-radius: 12px;
            padding: 12px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }
        
        .main-menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }
        
        .main-menu-btn:active {
            transform: scale(0.98);
        }
        
        .language-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .language-btn {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 8px 16px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .language-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .language-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
        }
        
        .language-dropdown.show {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }
        
        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .language-option:last-child {
            border-bottom: none;
        }
        
        .language-option:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        .language-option.active {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- 언어 선택기 -->
    <div class="language-selector">
        <button class="language-btn" onclick="toggleLanguageDropdown()">
            <i class="fas fa-globe mr-2"></i>
            <span id="currentLanguage">한국어</span>
            <i class="fas fa-chevron-down ml-2"></i>
        </button>
        <div class="language-dropdown" id="languageDropdown">
            <div class="language-option active" onclick="changeLanguage('ko')">
                <i class="fas fa-flag mr-2"></i><span data-i18n="korean">한국어</span>
            </div>
            <div class="language-option" onclick="changeLanguage('en')">
                <i class="fas fa-flag mr-2"></i><span data-i18n="english">English</span>
            </div>
            <div class="language-option" onclick="changeLanguage('es')">
                <i class="fas fa-flag mr-2"></i><span data-i18n="spanish">Español</span>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="glass-effect p-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center">
                <button onclick="window.location.href='index.html'" class="main-menu-btn mr-3">
                    <i class="fas fa-home text-lg"></i>
                </button>
                <button onclick="hideKeyboard()" class="main-menu-btn mr-3" title="키보드 숨김">
                    <i class="fas fa-keyboard text-lg"></i>
                </button>
                <button onclick="refreshPage()" class="main-menu-btn mr-3" title="새로고침">
                    <i class="fas fa-sync-alt text-lg"></i>
                </button>
                <div class="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center mr-3">
                    <i class="fas fa-arrow-down text-white text-lg"></i>
                </div>
                <div>
                    <h1 class="text-lg font-bold text-white" data-i18n="inbound_title">입고 작업</h1>
                    <p class="text-xs text-white/80" data-i18n="inbound_subtitle">컨테이너 스캔 및 확정</p>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <div class="w-8 h-8 bg-white/20 rounded-full flex items-center justify-center">
                    <i class="fas fa-user text-white text-sm"></i>
                </div>
                <div class="text-white/80 text-sm" id="currentTime">00:00:00</div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="p-4 space-y-6">
        <!-- Container Selection -->
        <div class="glass-card rounded-2xl p-6 animate-slide-up">
            <h2 class="text-lg font-bold text-gray-800 mb-4" data-i18n="container_selection">컨테이너 선택</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2" data-i18n="pending_container">PENDING 컨테이너</label>
                    <select id="containerSelect" class="dropdown-select">
                        <option value="" data-i18n="select_container">컨테이너를 선택하세요</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Scan Section -->
        <div id="scanSection" class="glass-card rounded-2xl p-6 animate-slide-up hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-4" data-i18n="barcode_scan">바코드 스캔</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2" data-i18n="part_number_scan">파트 번호 스캔</label>
                    <div class="flex space-x-2">
                        <input type="text" id="barcodeInput" class="scan-input flex-1" 
                               data-i18n-placeholder="scan_barcode_placeholder"
                               placeholder="바코드를 스캔하거나 파트 번호를 입력하세요" autocomplete="off">
                        <button onclick="clearScan()" class="action-button cancel-btn px-4 py-3 text-white" title="초기화">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Save/Cancel Buttons -->
        <div id="actionButtonsSection" class="glass-card rounded-2xl p-6 animate-slide-up hidden">
            <div class="flex space-x-3">
                <button onclick="confirmInbound()" class="action-button px-6 py-3 text-white flex-1">
                    <i class="fas fa-save mr-2"></i>저장
                </button>
                <button onclick="cancelInbound()" class="action-button cancel-btn px-6 py-3 text-white flex-1">
                    <i class="fas fa-times mr-2"></i>취소
                </button>
            </div>
        </div>

        <!-- Parts List -->
        <div id="partsSection" class="glass-card rounded-2xl p-6 animate-slide-up hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-4" data-i18n="parts_list">파트 목록</h2>
            <div class="bg-white rounded-lg shadow-sm overflow-hidden">
                <table class="w-full">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-sm font-medium text-gray-600" data-i18n="part_number">파트</th>
                            <th class="px-4 py-3 text-center text-sm font-medium text-gray-600" data-i18n="registered_quantity">등록 수량</th>
                            <th class="px-4 py-3 text-center text-sm font-medium text-gray-600" data-i18n="scanned_quantity">스캔 수량</th>
                            <th class="px-4 py-3 text-center text-sm font-medium text-gray-600" data-i18n="remaining_quantity">남은 수량</th>
                        </tr>
                    </thead>
                    <tbody id="partsList" class="divide-y divide-gray-200">
                        <!-- 파트 목록이 여기에 동적으로 추가됩니다 -->
                    </tbody>
                </table>
            </div>
        </div>


    </main>

    <!-- 하단 고정 홈 버튼 -->
    <div class="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-50">
        <button onclick="window.location.href='index.html'" 
                class="bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white px-8 py-4 rounded-full shadow-lg flex items-center space-x-2 transition-all duration-300 transform hover:scale-105">
            <i class="fas fa-home text-xl"></i>
            <span class="font-semibold" data-i18n="main_menu">메인 메뉴</span>
        </button>
    </div>

    <!-- Supabase 설정 및 스크립트 -->
    <script src="../js/config.js"></script>
    <script>
        // Supabase 클라이언트 초기화
        let supabase;
        let selectedContainer = null;
        let containerParts = [];
        
        function initializeSupabase() {
            try {
                console.log('=== Supabase 초기화 시작 ===');
                console.log('window.getCurrentConfig 존재 여부:', !!window.getCurrentConfig);
                console.log('window.supabase 존재 여부:', !!window.supabase);
                
                if (!window.getCurrentConfig) {
                    console.error('getCurrentConfig 함수를 찾을 수 없습니다. config.js가 로드되었는지 확인하세요.');
                    console.log('window 객체 확인:', Object.keys(window).filter(key => key.includes('config')));
                    return false;
                }
                
                const config = window.getCurrentConfig();
                console.log('설정 로드됨:', config);
                console.log('config.url:', config.url);
                console.log('config.anonKey 길이:', config.anonKey ? config.anonKey.length : 'undefined');
                
                if (!window.supabase) {
                    console.error('Supabase 라이브러리가 로드되지 않았습니다.');
                    console.log('window 객체 확인:', Object.keys(window).filter(key => key.includes('supabase')));
                    return false;
                }
                
                console.log('Supabase 클라이언트 생성 시작...');
                supabase = window.supabase.createClient(config.url, config.anonKey);
                console.log('Supabase 클라이언트 초기화 성공');
                console.log('supabase 객체:', supabase);
                return true;
            } catch (error) {
                console.error('Supabase 클라이언트 초기화 실패:', error);
                console.error('오류 상세:', error.message, error.stack);
                return false;
            }
        }

        // PENDING 컨테이너 목록 로드
        async function loadPendingContainers() {
            if (!supabase) {
                console.error('Supabase가 초기화되지 않았습니다.');
                return;
            }

            try {
                const { data: containers, error } = await supabase
                    .from('arn_containers')
                    .select('*')
                    .eq('status', 'PENDING')
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('컨테이너 데이터 로드 오류:', error);
                    return;
                }

                const select = document.getElementById('containerSelect');
                select.innerHTML = `<option value="" data-i18n="select_container">${i18n.t('select_container_placeholder')}</option>`;
                
                containers.forEach(container => {
                    const option = document.createElement('option');
                    option.value = container.arn_number;
                    option.textContent = `${container.container_number} (${container.arn_number})`;
                    select.appendChild(option);
                });

                console.log('PENDING 컨테이너 로드 완료:', containers.length);
            } catch (error) {
                console.error('컨테이너 로드 오류:', error);
            }
        }

        // 선택된 컨테이너의 파트 목록 로드
        async function loadContainerParts(arnNumber) {
            if (!supabase) {
                console.error('Supabase가 초기화되지 않았습니다.');
                return;
            }

            try {
                // arn_parts와 parts 테이블을 조인하여 카테고리 정보 가져오기
                const { data: parts, error } = await supabase
                    .from('arn_parts')
                    .select(`
                        *,
                        parts!inner(
                            part_number,
                            category
                        )
                    `)
                    .eq('arn_number', arnNumber);

                if (error) {
                    console.error('파트 데이터 로드 오류:', error);
                    return;
                }

                // parts 테이블의 카테고리 정보를 사용하도록 데이터 구조 변경
                // 스캔된 수량을 추적하기 위한 scannedQuantity 필드 추가
                containerParts = parts.map(part => ({
                    ...part,
                    category: part.parts?.category || 'N/A',
                    scannedQuantity: 0  // 스캔된 수량 초기화
                }));
                
                renderPartsList();
                updateProgress();
                
                console.log('컨테이너 파트 로드 완료:', parts.length);
            } catch (error) {
                console.error('파트 로드 오류:', error);
            }
        }

        // 파트 목록 렌더링
        function renderPartsList() {
            const partsList = document.getElementById('partsList');
            partsList.innerHTML = '';

            containerParts.forEach(part => {
                const partItem = document.createElement('tr');
                partItem.className = 'hover:bg-gray-50 transition-colors duration-200';
                partItem.id = `part-${part.part_number}`;
                
                const remainingQuantity = Math.max(0, part.quantity - part.scannedQuantity);
                const isCompleted = part.scannedQuantity === part.quantity;
                const isOver = part.scannedQuantity > part.quantity;
                const isUnder = part.scannedQuantity < part.quantity;
                
                // 수량 상태에 따라 색상 구분
                if (isCompleted) {
                    // 정확히 일치: 초록색
                    partItem.classList.add('bg-green-100', 'border-l-4', 'border-green-500');
                } else if (isOver) {
                    // 초과: 주황색
                    partItem.classList.add('bg-orange-100', 'border-l-4', 'border-orange-500');
                } else if (isUnder) {
                    // 부족: 빨간색
                    partItem.classList.add('bg-red-100', 'border-l-4', 'border-red-500');
                }

                partItem.innerHTML = `
                    <td class="px-4 py-3">
                        <div>
                            <div class="font-semibold text-gray-800">${part.part_number}</div>
                            <div class="text-sm text-gray-500">카테고리: ${part.category || 'N/A'}</div>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="font-medium text-gray-700">${part.quantity || 0}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        ${isCompleted ? 
                            `<span class="font-medium text-green-600">${part.scannedQuantity}</span>` :
                            isOver ? 
                                `<span class="font-medium text-orange-600">${part.scannedQuantity} <span class="text-xs">(+${part.scannedQuantity - part.quantity})</span></span>` :
                                `<span class="font-medium text-red-600">${part.scannedQuantity}</span>`
                        }
                    </td>
                    <td class="px-4 py-3 text-center">
                        ${isCompleted ? 
                            `<span class="font-medium text-green-600">0</span>` :
                            `<span class="font-medium ${remainingQuantity < part.quantity * 0.5 ? 'text-yellow-600' : 'text-gray-500'}">${remainingQuantity}</span>`
                        }
                    </td>
                `;

                partsList.appendChild(partItem);
            });
        }

        // 진행 상황 업데이트 (간소화 - 저장 버튼 표시만)
        function updateProgress() {
            const totalParts = containerParts.length;
            const completedParts = containerParts.filter(part => part.scannedQuantity === part.quantity).length;
            const overParts = containerParts.filter(part => part.scannedQuantity > part.quantity).length;
            const underParts = containerParts.filter(part => part.scannedQuantity < part.quantity).length;

            // 모든 파트가 정확히 일치할 때만 저장 버튼 활성화 (항상 표시되지만 시각적 피드백 제공)
            // 버튼은 항상 표시되므로 여기서는 추가 로직 없음
        }

        // 스캔된 고유코드를 추적하기 위한 Set
        const scannedUniqueCodes = new Set();

        // 바코드 스캔 처리
        async function handleBarcodeScan(barcode) {
            console.log('바코드 스캔 처리 시작:', barcode);
            console.log('현재 컨테이너 파트 목록:', containerParts.map(p => ({ part_number: p.part_number, category: p.category })));
            
            // GS1-128 바코드 파싱 시도
            const parsedData = parseGS1Barcode(barcode);
            
            if (parsedData) {
                console.log('바코드 파싱 성공, 파트 번호 검색:', parsedData.partNumber);
                console.log('추출된 수량:', parsedData.quantity);
                console.log('추출된 고유코드:', parsedData.uniqueNumber);
                
                // 고유코드가 있는 경우 중복 검사 (메모리 + DB)
                if (parsedData.uniqueNumber) {
                    // 1. 메모리상의 중복 체크 (가장 빠른 체크)
                    if (scannedUniqueCodes.has(parsedData.uniqueNumber)) {
                        console.log('고유코드 중복 감지 (메모리):', parsedData.uniqueNumber);
                        showNotification(`❌ 중복 스캔: 이미 스캔된 고유코드입니다.\n고유코드: ${parsedData.uniqueNumber}`, 'error');
                        
                        const barcodeInput = document.getElementById('barcodeInput');
                        barcodeInput.value = '';
                        setTimeout(() => {
                            barcodeInput.focus();
                            barcodeInput.select();
                        }, 100);
                        
                        return false;
                    }
                    
                    // 2. DB에서 중복 체크 (같은 컨테이너에서 이미 스캔된 경우 확인)
                    // 주의: 메모리 Set에 없으면 첫 스캔이므로, DB 체크는 선택적으로만 수행
                    // 메모리 Set이 최우선이고, DB는 보조 확인용
                    try {
                        const { data: existingCode, error: checkError } = await supabase
                            .from('scanned_unique_codes')
                            .select('id, arn_number, part_number, status')
                            .eq('unique_code', parsedData.uniqueNumber)
                            .single();
                        
                        // PGRST116은 "not found" 오류 - 정상적인 경우 (첫 스캔)
                        if (checkError && checkError.code === 'PGRST116') {
                            // 첫 스캔이므로 DB에 없음 - 정상, 계속 진행
                            console.log('첫 스캔 (DB에 없음):', parsedData.uniqueNumber);
                        } else if (checkError) {
                            // 다른 오류인 경우만 경고
                            console.warn('고유코드 중복 체크 오류 (무시하고 진행):', checkError);
                        } else if (existingCode) {
                            // DB에 존재하는 경우만 중복 체크
                            console.log('고유코드 중복 감지 (DB):', parsedData.uniqueNumber, existingCode);
                            
                            // 상태가 COMPLETED인 경우 - 다른 ARN으로 이미 입고 완료된 경우 절대 재입고 불가
                            if (existingCode.status === 'COMPLETED') {
                                const currentArn = selectedContainer?.arn_number || '미선택';
                                const existingArn = existingCode.arn_number || '알 수 없음';
                                
                                // 현재 선택한 컨테이너와 다른 ARN으로 입고 완료된 경우
                                if (selectedContainer && existingCode.arn_number !== selectedContainer.arn_number) {
                                    showNotification(`❌ 입고 불가: 이 고유코드는 이미 다른 컨테이너(${existingArn})로 입고 완료되었습니다.\n현재 컨테이너: ${currentArn}`, 'error');
                                } else {
                                    showNotification(`❌ 입고 불가: 이미 입고 완료된 고유코드입니다.\n고유코드: ${parsedData.uniqueNumber}\n컨테이너: ${existingArn}`, 'error');
                                }
                                
                                const barcodeInput = document.getElementById('barcodeInput');
                                barcodeInput.value = '';
                                setTimeout(() => {
                                    barcodeInput.focus();
                                    barcodeInput.select();
                                }, 100);
                                
                                return false;
                            } else {
                                // PENDING 상태인 경우 - 같은 컨테이너에서 이미 스캔된 경우 중복 스캔 차단
                                const currentArn = selectedContainer?.arn_number || '미선택';
                                const existingArn = existingCode.arn_number || '알 수 없음';
                                
                                if (selectedContainer && existingCode.arn_number === selectedContainer.arn_number) {
                                    // 같은 컨테이너에서 이미 스캔된 경우 - 중복 스캔 차단 (수량 증가 방지)
                                    console.log('같은 컨테이너의 PENDING 항목 - 중복 스캔 차단');
                                    showNotification(`❌ 중복 스캔: 이 고유코드는 이미 스캔되었습니다.\n고유코드: ${parsedData.uniqueNumber}\n컨테이너: ${currentArn}`, 'error');
                                    
                                    const barcodeInput = document.getElementById('barcodeInput');
                                    barcodeInput.value = '';
                                    setTimeout(() => {
                                        barcodeInput.focus();
                                        barcodeInput.select();
                                    }, 100);
                                    
                                    return false;
                                } else {
                                    // 다른 컨테이너에서 PENDING 상태인 경우
                                    // 사용자가 실수로 다른 컨테이너를 선택했을 수 있으므로, 기존 레코드를 삭제하고 현재 컨테이너로 재스캔 허용
                                    console.log('다른 컨테이너의 PENDING 항목 감지 - 기존 레코드 삭제 후 재스캔 허용');
                                    
                                    try {
                                        // 기존 PENDING 레코드 삭제
                                        const { error: deleteError } = await supabase
                                            .from('scanned_unique_codes')
                                            .delete()
                                            .eq('unique_code', parsedData.uniqueNumber)
                                            .eq('status', 'PENDING');
                                        
                                        if (deleteError) {
                                            console.warn('기존 PENDING 레코드 삭제 오류:', deleteError);
                                            showNotification(`❌ 중복 스캔: 이 고유코드는 다른 컨테이너(${existingArn})에서 이미 스캔되었습니다.\n현재 컨테이너: ${currentArn}`, 'error');
                                            
                                            const barcodeInput = document.getElementById('barcodeInput');
                                            barcodeInput.value = '';
                                            setTimeout(() => {
                                                barcodeInput.focus();
                                                barcodeInput.select();
                                            }, 100);
                                            
                                            return false;
                                        } else {
                                            console.log('기존 PENDING 레코드 삭제 완료 - 재스캔 진행');
                                            // 삭제 성공 시 계속 진행 (아래 코드에서 새로 저장됨)
                                        }
                                    } catch (deleteErr) {
                                        console.error('기존 레코드 삭제 중 오류:', deleteErr);
                                        showNotification(`❌ 중복 스캔: 이 고유코드는 다른 컨테이너(${existingArn})에서 이미 스캔되었습니다.`, 'error');
                                        
                                        const barcodeInput = document.getElementById('barcodeInput');
                                        barcodeInput.value = '';
                                        setTimeout(() => {
                                            barcodeInput.focus();
                                            barcodeInput.select();
                                        }, 100);
                                        
                                        return false;
                                    }
                                }
                            }
                        }
                    } catch (dbError) {
                        console.error('DB 중복 체크 중 오류:', dbError);
                        // DB 오류가 있어도 진행 (메모리 체크는 통과했으므로)
                    }
                }
                
                // 파싱된 파트 번호로 검색 (컨테이너 파트 목록에서 먼저 찾기)
                // 관리자 화면에서 등록한 입고 정보(arn_parts)와 매칭
                // 정확히 일치하는 경우와 하이픈 변형도 시도
                let part = containerParts.find(p => p.part_number === parsedData.partNumber);
                
                // 정확히 일치하지 않으면 하이픈 없는 형식도 시도 (49560-CW150 <-> 49560CW150)
                if (!part) {
                    const withoutHyphen = parsedData.partNumber.replace('-', '');
                    part = containerParts.find(p => p.part_number === withoutHyphen || p.part_number.replace('-', '') === withoutHyphen);
                    if (part) {
                        console.log('하이픈 변형으로 매칭 성공:', parsedData.partNumber, '→', part.part_number);
                    }
                }
                
                // 컨테이너에 등록되지 않은 파트인 경우 Supabase에서 조회
                if (!part) {
                    console.log('컨테이너 파트 목록에 없음, Supabase에서 조회 시도:', parsedData.partNumber);
                    try {
                        // 정확히 일치하는 파트 먼저 찾기
                        let { data: partData, error: partError } = await supabase
                            .from('parts')
                            .select('part_number, category')
                            .eq('part_number', parsedData.partNumber)
                            .single();
                        
                        // 정확히 일치하지 않으면 하이픈 없는 형식도 시도
                        if (partError || !partData) {
                            console.log('정확히 일치하는 파트 없음, 하이픈 없는 형식 시도:', parsedData.partNumber);
                            const withoutHyphen = parsedData.partNumber.replace('-', '');
                            const { data: allParts, error: allPartsError } = await supabase
                                .from('parts')
                                .select('part_number, category');
                            
                            if (!allPartsError && allParts) {
                                // 하이픈 포함/미포함 모두 비교
                                partData = allParts.find(p => 
                                    p.part_number === parsedData.partNumber ||
                                    p.part_number === withoutHyphen ||
                                    p.part_number.replace('-', '') === withoutHyphen ||
                                    parsedData.partNumber.replace('-', '') === p.part_number.replace('-', '')
                                );
                                
                                if (partData) {
                                    console.log('하이픈 변형으로 Supabase에서 파트 찾음:', partData);
                                    partError = null;
                                }
                            }
                        }
                        
                        if (partError || !partData) {
                            console.log('Supabase에서도 파트를 찾을 수 없음:', parsedData.partNumber);
                            showNotification(`파트 번호 ${parsedData.partNumber}를 찾을 수 없습니다. (Supabase에 등록되지 않음)`, 'error');
                            return false;
                        }
                        
                        // Supabase에서 찾은 파트를 containerParts에 동적으로 추가
                        console.log('Supabase에서 파트 찾음, 목록에 추가:', partData);
                        const newPart = {
                            part_number: partData.part_number, // Supabase에 저장된 실제 형식 사용
                            category: partData.category || 'N/A',
                            quantity: 0, // 등록 수량 없음 (동적 추가)
                            scannedQuantity: 0,
                            arn_number: selectedContainer?.arn_number || 'DYNAMIC'
                        };
                        containerParts.push(newPart);
                        part = newPart;
                        console.log('동적으로 파트 추가됨:', part);
                    } catch (error) {
                        console.error('파트 조회 오류:', error);
                        showNotification(`파트 번호 ${parsedData.partNumber} 조회 중 오류가 발생했습니다.`, 'error');
                        return false;
                    }
                }
                
                if (part) {
                    console.log('파트 매칭 성공:', part);
                    console.log('선택한 컨테이너:', selectedContainer?.arn_number, '파트 번호:', part.part_number);
                    
                    // 고유코드가 있으면 먼저 DB에 저장 시도 (중복 방지)
                    if (parsedData.uniqueNumber) {
                        // 먼저 메모리 Set에 추가 (race condition 방지)
                        if (scannedUniqueCodes.has(parsedData.uniqueNumber)) {
                            console.log('고유코드 중복 감지 (메모리 - 파트 매칭 후):', parsedData.uniqueNumber);
                            showNotification(`이미 스캔된 고유코드입니다: ${parsedData.uniqueNumber}`, 'error');
                            
                            const barcodeInput = document.getElementById('barcodeInput');
                            barcodeInput.value = '';
                            setTimeout(() => {
                                barcodeInput.focus();
                                barcodeInput.select();
                            }, 100);
                            
                            return false;
                        }
                        
                        // 메모리 Set에 먼저 추가 (동시 스캔 방지)
                        scannedUniqueCodes.add(parsedData.uniqueNumber);
                        console.log('고유코드 메모리 등록됨:', parsedData.uniqueNumber);
                        
                        // 스캔 시점에 바로 DB에 저장 (PENDING 상태)
                        // UNIQUE 제약조건으로 중복 방지
                        try {
                            const { error: insertError } = await supabase
                                .from('scanned_unique_codes')
                                .insert({
                                    unique_code: parsedData.uniqueNumber,
                                    arn_number: selectedContainer?.arn_number || null,
                                    part_number: part.part_number,
                                    quantity: parsedData.quantity,
                                    status: 'PENDING',
                                    scanned_at: new Date().toISOString()
                                });
                            
                            if (insertError) {
                                // UNIQUE 제약조건 위반은 이미 저장된 것이므로 중복 스캔으로 처리
                                if (insertError.code === '23505') {
                                    console.log('고유번호가 이미 DB에 저장되어 있음 (중복 스캔):', parsedData.uniqueNumber);
                                    // 메모리에서도 제거
                                    scannedUniqueCodes.delete(parsedData.uniqueNumber);
                                    
                                    showNotification(`❌ 중복 스캔: 이 고유코드는 이미 스캔되었습니다.\n고유코드: ${parsedData.uniqueNumber}`, 'error');
                                    
                                    const barcodeInput = document.getElementById('barcodeInput');
                                    barcodeInput.value = '';
                                    setTimeout(() => {
                                        barcodeInput.focus();
                                        barcodeInput.select();
                                    }, 100);
                                    
                                    return false;
                                } else {
                                    console.warn('고유번호 저장 오류:', insertError);
                                    // 저장 실패 시 메모리에서도 제거
                                    scannedUniqueCodes.delete(parsedData.uniqueNumber);
                                    
                                    // 권한 오류인 경우 더 명확한 메시지 표시
                                    let errorMessage = `고유번호 저장 오류: ${insertError.message}`;
                                    if (insertError.message && insertError.message.includes('permission denied')) {
                                        errorMessage = `❌ 권한 오류: scanned_unique_codes 테이블에 대한 권한이 없습니다.\n데이터베이스 관리자에게 권한 설정을 요청하세요.\n\n오류 상세: ${insertError.message}`;
                                    }
                                    
                                    showNotification(errorMessage, 'error');
                                    
                                    const barcodeInput = document.getElementById('barcodeInput');
                                    barcodeInput.value = '';
                                    
                                    return false;
                                }
                            } else {
                                console.log('고유번호 DB 저장 완료:', parsedData.uniqueNumber, '컨테이너:', selectedContainer?.arn_number, '파트:', part.part_number);
                                
                                // DB 저장 성공 후 파트 객체에 고유번호 배열로 저장 (나중에 입고 확정 시 참조용)
                                if (!part.scannedUniqueCodes) {
                                    part.scannedUniqueCodes = [];
                                }
                                // 중복 방지
                                if (!part.scannedUniqueCodes.includes(parsedData.uniqueNumber)) {
                                    part.scannedUniqueCodes.push(parsedData.uniqueNumber);
                                }
                                
                                // DB 저장 성공 시에만 수량 추가 (중복 스캔 방지)
                                part.scannedQuantity += parsedData.quantity;
                            }
                        } catch (saveError) {
                            console.error('고유번호 저장 중 오류:', saveError);
                            // 저장 실패 시 메모리에서도 제거
                            scannedUniqueCodes.delete(parsedData.uniqueNumber);
                            
                            // 권한 오류인 경우 더 명확한 메시지 표시
                            let errorMessage = `고유번호 저장 중 오류가 발생했습니다.`;
                            if (saveError.message && saveError.message.includes('permission denied')) {
                                errorMessage = `❌ 권한 오류: scanned_unique_codes 테이블에 대한 권한이 없습니다.\n데이터베이스 관리자에게 권한 설정을 요청하세요.\n\n오류 상세: ${saveError.message}`;
                            } else if (saveError.message) {
                                errorMessage = `고유번호 저장 중 오류: ${saveError.message}`;
                            }
                            
                            showNotification(errorMessage, 'error');
                            
                            const barcodeInput = document.getElementById('barcodeInput');
                            barcodeInput.value = '';
                            
                            return false;
                        }
                    } else {
                        console.log('고유코드 없음 (중복 검사 건너뜀)');
                        // 고유코드가 없는 경우에만 수량 추가
                        part.scannedQuantity += parsedData.quantity;
                    }
                    
                    renderPartsList();
                    updateProgress();
                    
                    // 입력 필드 초기화 및 포커스 유지
                    const barcodeInput = document.getElementById('barcodeInput');
                    barcodeInput.value = '';
                    setTimeout(() => {
                        barcodeInput.focus();
                        barcodeInput.select();
                    }, 100);
                    
                    return true;
                } else {
                    console.log('파트 매칭 실패. 사용 가능한 파트:', containerParts.map(p => p.part_number));
                    showNotification(`파트 번호 ${parsedData.partNumber}를 찾을 수 없습니다.`, 'error');
                    return false;
                }
            } else {
                console.log('바코드 파싱 실패, 직접 파트 번호 입력 시도');
                
                // 직접 파트 번호 입력인 경우에도 중복 검사 (전체 바코드를 고유코드로 사용)
                // 1. 메모리상의 중복 체크
                if (scannedUniqueCodes.has(barcode)) {
                    console.log('직접 입력 바코드 중복 감지 (메모리):', barcode);
                    showNotification(`이미 스캔된 바코드입니다: ${barcode}`, 'error');
                    
                    const barcodeInput = document.getElementById('barcodeInput');
                    barcodeInput.value = '';
                    setTimeout(() => {
                        barcodeInput.focus();
                        barcodeInput.select();
                    }, 100);
                    
                    return false;
                }
                
                // 2. DB에서 중복 체크 (scanned_unique_codes 테이블에서 확인)
                // 주의: 메모리 Set에 없으면 첫 스캔이므로, DB 체크는 선택적으로만 수행
                try {
                    const { data: existingCode, error: checkError } = await supabase
                        .from('scanned_unique_codes')
                        .select('id, arn_number, part_number, status')
                        .eq('unique_code', barcode)
                        .single();
                    
                    // PGRST116은 "not found" 오류 - 정상적인 경우 (첫 스캔)
                    if (checkError && checkError.code === 'PGRST116') {
                        // 첫 스캔이므로 DB에 없음 - 정상, 계속 진행
                        console.log('첫 스캔 (DB에 없음):', barcode);
                    } else if (checkError) {
                        // 다른 오류인 경우만 경고
                        console.warn('바코드 중복 체크 오류 (무시하고 진행):', checkError);
                    } else if (existingCode) {
                        // DB에 존재하는 경우만 중복 체크
                        console.log('바코드 중복 감지 (DB):', barcode, existingCode);
                        
                        // 상태가 COMPLETED인 경우 - 다른 ARN으로 이미 입고 완료된 경우 절대 재입고 불가
                        if (existingCode.status === 'COMPLETED') {
                            const currentArn = selectedContainer?.arn_number || '미선택';
                            const existingArn = existingCode.arn_number || '알 수 없음';
                            
                            // 현재 선택한 컨테이너와 다른 ARN으로 입고 완료된 경우
                            if (selectedContainer && existingCode.arn_number !== selectedContainer.arn_number) {
                                showNotification(`❌ 입고 불가: 이 바코드는 이미 다른 컨테이너(${existingArn})로 입고 완료되었습니다.\n현재 컨테이너: ${currentArn}`, 'error');
                            } else {
                                showNotification(`❌ 입고 불가: 이미 입고 완료된 바코드입니다.\n바코드: ${barcode}\n컨테이너: ${existingArn}`, 'error');
                            }
                            
                            const barcodeInput = document.getElementById('barcodeInput');
                            barcodeInput.value = '';
                            setTimeout(() => {
                                barcodeInput.focus();
                                barcodeInput.select();
                            }, 100);
                            
                            return false;
                        } else {
                            // PENDING 상태인 경우 - 중복 스캔 차단
                            const currentArn = selectedContainer?.arn_number || '미선택';
                            const existingArn = existingCode.arn_number || '알 수 없음';
                            
                            if (selectedContainer && existingCode.arn_number === selectedContainer.arn_number) {
                                // 같은 컨테이너에서 이미 스캔된 경우 - 중복 스캔 차단
                                console.log('같은 컨테이너의 PENDING 항목 - 중복 스캔 차단');
                                showNotification(`❌ 중복 스캔: 이 바코드는 이미 스캔되었습니다.\n바코드: ${barcode}\n컨테이너: ${currentArn}`, 'error');
                                
                                const barcodeInput = document.getElementById('barcodeInput');
                                barcodeInput.value = '';
                                setTimeout(() => {
                                    barcodeInput.focus();
                                    barcodeInput.select();
                                }, 100);
                                
                                return false;
                            } else {
                                // 다른 컨테이너에서 PENDING 상태인 경우
                                // 사용자가 실수로 다른 컨테이너를 선택했을 수 있으므로, 기존 레코드를 삭제하고 현재 컨테이너로 재스캔 허용
                                console.log('다른 컨테이너의 PENDING 항목 감지 - 기존 레코드 삭제 후 재스캔 허용');
                                
                                try {
                                    // 기존 PENDING 레코드 삭제
                                    const { error: deleteError } = await supabase
                                        .from('scanned_unique_codes')
                                        .delete()
                                        .eq('unique_code', barcode)
                                        .eq('status', 'PENDING');
                                    
                                    if (deleteError) {
                                        console.warn('기존 PENDING 레코드 삭제 오류:', deleteError);
                                        showNotification(`❌ 중복 스캔: 이 바코드는 다른 컨테이너(${existingArn})에서 이미 스캔되었습니다.\n현재 컨테이너: ${currentArn}`, 'error');
                                        
                                        const barcodeInput = document.getElementById('barcodeInput');
                                        barcodeInput.value = '';
                                        setTimeout(() => {
                                            barcodeInput.focus();
                                            barcodeInput.select();
                                        }, 100);
                                        
                                        return false;
                                    } else {
                                        console.log('기존 PENDING 레코드 삭제 완료 - 재스캔 진행');
                                        // 삭제 성공 시 계속 진행 (아래 코드에서 새로 저장됨)
                                    }
                                } catch (deleteErr) {
                                    console.error('기존 레코드 삭제 중 오류:', deleteErr);
                                    showNotification(`❌ 중복 스캔: 이 바코드는 다른 컨테이너(${existingArn})에서 이미 스캔되었습니다.`, 'error');
                                    
                                    const barcodeInput = document.getElementById('barcodeInput');
                                    barcodeInput.value = '';
                                    setTimeout(() => {
                                        barcodeInput.focus();
                                        barcodeInput.select();
                                    }, 100);
                                    
                                    return false;
                                }
                            }
                        }
                    }
                } catch (dbError) {
                    console.error('DB 중복 체크 중 오류:', dbError);
                    // DB 오류가 있어도 진행
                }
                
                // 직접 파트 번호 입력인 경우 (수량 1로 처리)
                // 하이픈 포함/미포함 모두 시도
                let part = containerParts.find(p => p.part_number === barcode);
                
                // 하이픈 없는 형식도 시도 (49601S9000 -> 49601-S9000)
                if (!part) {
                    const hyphenMatch = barcode.match(/^(\d{5})([A-Z])(\d{4})$/);
                    if (hyphenMatch) {
                        const hyphenated = `${hyphenMatch[1]}-${hyphenMatch[2]}${hyphenMatch[3]}`;
                        part = containerParts.find(p => p.part_number === hyphenated);
                        if (part) {
                            console.log('하이픈 추가하여 매칭 성공:', hyphenated);
                        }
                    }
                }
                
                if (part) {
                    console.log('직접 파트 번호 매칭 성공:', part);
                    
                    // 먼저 메모리 Set에 추가 (race condition 방지)
                    if (scannedUniqueCodes.has(barcode)) {
                        console.log('직접 입력 바코드 중복 감지 (메모리 - 파트 매칭 후):', barcode);
                        showNotification(`이미 스캔된 바코드입니다: ${barcode}`, 'error');
                        
                        const barcodeInput = document.getElementById('barcodeInput');
                        barcodeInput.value = '';
                        setTimeout(() => {
                            barcodeInput.focus();
                            barcodeInput.select();
                        }, 100);
                        
                        return false;
                    }
                    
                    // 메모리 Set에 먼저 추가 (동시 스캔 방지)
                    scannedUniqueCodes.add(barcode);
                    console.log('직접 입력 바코드 메모리 등록됨:', barcode);
                    
                    // 스캔 시점에 바로 DB에 저장 (PENDING 상태)
                    // UNIQUE 제약조건으로 중복 방지
                    try {
                        const { error: insertError } = await supabase
                            .from('scanned_unique_codes')
                            .insert({
                                unique_code: barcode,
                                arn_number: selectedContainer?.arn_number || null,
                                part_number: part.part_number,
                                quantity: 1,
                                status: 'PENDING',
                                scanned_at: new Date().toISOString()
                            });
                        
                        if (insertError) {
                            // UNIQUE 제약조건 위반은 이미 저장된 것이므로 중복 스캔으로 처리
                            if (insertError.code === '23505') {
                                console.log('바코드가 이미 DB에 저장되어 있음 (중복 스캔):', barcode);
                                // 메모리에서도 제거
                                scannedUniqueCodes.delete(barcode);
                                
                                showNotification(`❌ 중복 스캔: 이 바코드는 이미 스캔되었습니다.\n바코드: ${barcode}`, 'error');
                                
                                const barcodeInput = document.getElementById('barcodeInput');
                                barcodeInput.value = '';
                                setTimeout(() => {
                                    barcodeInput.focus();
                                    barcodeInput.select();
                                }, 100);
                                
                                return false;
                            } else {
                                console.warn('바코드 저장 오류:', insertError);
                                // 저장 실패 시 메모리에서도 제거
                                scannedUniqueCodes.delete(barcode);
                                
                                // 권한 오류인 경우 더 명확한 메시지 표시
                                let errorMessage = `바코드 저장 오류: ${insertError.message}`;
                                if (insertError.message && insertError.message.includes('permission denied')) {
                                    errorMessage = `❌ 권한 오류: scanned_unique_codes 테이블에 대한 권한이 없습니다.\n데이터베이스 관리자에게 권한 설정을 요청하세요.\n\n오류 상세: ${insertError.message}`;
                                }
                                
                                showNotification(errorMessage, 'error');
                                
                                const barcodeInput = document.getElementById('barcodeInput');
                                barcodeInput.value = '';
                                
                                return false;
                            }
                        } else {
                            console.log('바코드 DB 저장 완료:', barcode, '컨테이너:', selectedContainer?.arn_number, '파트:', part.part_number);
                            
                            // DB 저장 성공 후 파트 객체에 고유번호 배열로 저장 (나중에 입고 확정 시 참조용)
                            if (!part.scannedUniqueCodes) {
                                part.scannedUniqueCodes = [];
                            }
                            // 중복 방지
                            if (!part.scannedUniqueCodes.includes(barcode)) {
                                part.scannedUniqueCodes.push(barcode);
                            }
                            
                            // DB 저장 성공 시에만 수량 추가 (중복 스캔 방지)
                            part.scannedQuantity += 1;
                        }
                    } catch (saveError) {
                        console.error('바코드 저장 중 오류:', saveError);
                        // 저장 실패 시 메모리에서도 제거
                        scannedUniqueCodes.delete(barcode);
                        
                        // 권한 오류인 경우 더 명확한 메시지 표시
                        let errorMessage = `바코드 저장 중 오류가 발생했습니다.`;
                        if (saveError.message && saveError.message.includes('permission denied')) {
                            errorMessage = `❌ 권한 오류: scanned_unique_codes 테이블에 대한 권한이 없습니다.\n데이터베이스 관리자에게 권한 설정을 요청하세요.\n\n오류 상세: ${saveError.message}`;
                        } else if (saveError.message) {
                            errorMessage = `바코드 저장 중 오류: ${saveError.message}`;
                        }
                        
                        showNotification(errorMessage, 'error');
                        
                        const barcodeInput = document.getElementById('barcodeInput');
                        barcodeInput.value = '';
                        
                        return false;
                    }
                    
                    renderPartsList();
                    updateProgress();
                    
                    // 입력 필드 초기화 및 포커스 유지
                    const barcodeInput = document.getElementById('barcodeInput');
                    barcodeInput.value = '';
                    setTimeout(() => {
                        barcodeInput.focus();
                        barcodeInput.select();
                    }, 100);
                    
                    return true;
                } else {
                    showNotification(`파트 번호 ${barcode}를 찾을 수 없습니다.`, 'error');
                    return false;
                }
            }
        }

        // GS1-128 바코드 파싱 함수 (다양한 형식 지원)
        function parseGS1Barcode(barcode) {
            try {
                console.log('바코드 파싱 시작:', barcode);
                
                // ===== 형식 1: GS1-128 표준 형식 =====
                // [)>*06:D032125:5K:23L :24L :P49560l3010:7Q50:3SP11000321253583:VP1100*EOT
                // [)>*06:D082225:5K:23L:24L:P49560CW150:7Q80:3SP1100082225460:VP1100*EOT
                if (barcode.includes('[)>*06:') || barcode.includes('*EOT')) {
                    console.log('GS1-128 표준 형식 감지');
                    
                    // 파트 번호 추출 - 다양한 형식 지원
                    // P49560L3010 (5자리 숫자 + 알파벳 1개 + 4자리 숫자)
                    // P49560CW150 (5자리 숫자 + 알파벳 2개 + 3자리 숫자)
                    // P49560l3010 (소문자 포함)
                    const partMatch = barcode.match(/P\d{5}[a-zA-Z]+\d{3,4}/);
                    if (!partMatch) {
                        console.log('GS1-128 파트 번호 매칭 실패');
                        return null;
                    }
                    let partNumber = partMatch[0];
                    console.log('추출된 파트 번호 (P 포함):', partNumber);
                    
                    // P 접두사 제거 (P49560CW150 -> 49560CW150)
                    if (partNumber.startsWith('P')) {
                        partNumber = partNumber.substring(1);
                        console.log('P 접두사 제거 후:', partNumber);
                    }
                    
                    // DB 형식에 맞게 하이픈 추가
                    // 49560L3010 -> 49560-L3010 (알파벳 1개 + 숫자 4자리)
                    // 49560CW150 -> 49560-CW150 (알파벳 2개 + 숫자 3자리)
                    // 49560l3010 -> 49560-L3010 (소문자 포함)
                    const hyphenMatch1 = partNumber.match(/^(\d{5})([A-Za-z])(\d{4})$/); // 알파벳 1개 + 숫자 4자리
                    const hyphenMatch2 = partNumber.match(/^(\d{5})([A-Za-z]{2})(\d{3})$/); // 알파벳 2개 + 숫자 3자리
                    const hyphenMatch3 = partNumber.match(/^(\d{5})([A-Za-z]+)(\d{3,4})$/); // 일반적인 경우
                    
                    if (hyphenMatch1) {
                        partNumber = `${hyphenMatch1[1]}-${hyphenMatch1[2]}${hyphenMatch1[3]}`;
                        console.log('하이픈 추가 후 (패턴1):', partNumber);
                    } else if (hyphenMatch2) {
                        partNumber = `${hyphenMatch2[1]}-${hyphenMatch2[2]}${hyphenMatch2[3]}`;
                        console.log('하이픈 추가 후 (패턴2):', partNumber);
                    } else if (hyphenMatch3) {
                        // 알파벳과 숫자 사이에 하이픈 추가
                        const letters = hyphenMatch3[2].toUpperCase(); // 소문자를 대문자로 변환
                        partNumber = `${hyphenMatch3[1]}-${letters}${hyphenMatch3[3]}`;
                        console.log('하이픈 추가 후 (패턴3):', partNumber);
                    }
                    
                    // 수량 추출 (7Q50 -> 50)
                    const quantityMatch = barcode.match(/7Q(\d+)/);
                    if (!quantityMatch) {
                        console.log('GS1-128 수량 매칭 실패');
                        return null;
                    }
                    const quantity = parseInt(quantityMatch[1]);
                    console.log('추출된 수량:', quantity);
                    
                    // 유니크 넘버 추출 (3SP11000321253583 -> P11000321253583 또는 3SP11000321253583)
                    // 패턴 1: 3SP로 시작하는 경우 (3SP11000321253583)
                    let uniqueMatch = barcode.match(/3SP([^:*]+)/);
                    let uniqueNumber = null;
                    
                    if (uniqueMatch) {
                        // P 접두사 포함하여 저장 (P11000321253583)
                        uniqueNumber = 'P' + uniqueMatch[1];
                        console.log('추출된 유니크 넘버 (패턴1):', uniqueNumber);
                    } else {
                        // 패턴 2: 3S로 시작하는 경우 (3S 뒤의 값)
                        uniqueMatch = barcode.match(/3S([^:*]+)/);
                        if (uniqueMatch) {
                            uniqueNumber = uniqueMatch[1];
                            console.log('추출된 유니크 넘버 (패턴2):', uniqueNumber);
                        } else {
                            console.log('GS1-128 유니크 넘버 매칭 실패, 전체 바코드를 고유코드로 사용');
                            // 고유코드가 없으면 전체 바코드를 고유코드로 사용
                            uniqueNumber = barcode;
                        }
                    }
                    
                    return {
                        partNumber,
                        quantity,
                        uniqueNumber
                    };
                }
                
                // ===== 형식 2: QR 코드 또는 라벨 텍스트 형식 =====
                // 예: "49601-S9000:80:P1100082225460" 또는 "Part:49601-S9000 Qty:80 Tag:P1100082225460"
                console.log('GS1-128 표준 형식 아님, 라벨 텍스트 형식 시도');
                
                // 패턴 1: "파트번호:수량:태그번호" 형식
                const pattern1 = barcode.match(/^(\d{5}-[A-Z]\d{4}):(\d+):(P\d+)$/);
                if (pattern1) {
                    console.log('패턴 1 매칭 성공:', pattern1);
                    return {
                        partNumber: pattern1[1], // 49601-S9000
                        quantity: parseInt(pattern1[2]), // 80
                        uniqueNumber: pattern1[3] // P1100082225460
                    };
                }
                
                // 패턴 2: "파트번호:수량" 형식 (태그번호 없음)
                const pattern2 = barcode.match(/^(\d{5}-[A-Z]\d{4}):(\d+)$/);
                if (pattern2) {
                    console.log('패턴 2 매칭 성공:', pattern2);
                    return {
                        partNumber: pattern2[1], // 49601-S9000
                        quantity: parseInt(pattern2[2]), // 80
                        uniqueNumber: null // 태그번호 없음
                    };
                }
                
                // 패턴 3: 하이픈 포함 파트 번호만 (수량 1, 태그번호 없음)
                const pattern3 = barcode.match(/^(\d{5}-[A-Z]\d{4})$/);
                if (pattern3) {
                    console.log('패턴 3 매칭 성공 (파트 번호만):', pattern3);
                    return {
                        partNumber: pattern3[1], // 49601-S9000
                        quantity: 1, // 기본값
                        uniqueNumber: null
                    };
                }
                
                // 패턴 4: "Part:49601-S9000 Qty:80 Tag:P1100082225460" 형식
                const partMatch4 = barcode.match(/Part[:\s]+(\d{5}-[A-Z]\d{4})/i);
                const qtyMatch4 = barcode.match(/Qty[:\s]+(\d+)/i);
                const tagMatch4 = barcode.match(/Tag[:\s]+(P\d+)/i);
                
                if (partMatch4) {
                    console.log('패턴 4 매칭 성공:', { part: partMatch4[1], qty: qtyMatch4?.[1], tag: tagMatch4?.[1] });
                    return {
                        partNumber: partMatch4[1],
                        quantity: qtyMatch4 ? parseInt(qtyMatch4[1]) : 1,
                        uniqueNumber: tagMatch4 ? tagMatch4[1] : null
                    };
                }
                
                // 패턴 5: QR 코드가 여러 줄로 나뉘어 있는 경우
                // "49601-S9000\n80\nP1100082225460" 형식
                const lines = barcode.split('\n').map(l => l.trim()).filter(l => l);
                if (lines.length >= 2) {
                    const partLine = lines.find(l => /^\d{5}-[A-Z]\d{4}$/.test(l));
                    const qtyLine = lines.find(l => /^\d+$/.test(l));
                    const tagLine = lines.find(l => /^P\d+$/.test(l));
                    
                    if (partLine) {
                        console.log('패턴 5 매칭 성공 (여러 줄):', { part: partLine, qty: qtyLine, tag: tagLine });
                        return {
                            partNumber: partLine,
                            quantity: qtyLine ? parseInt(qtyLine) : 1,
                            uniqueNumber: tagLine || null
                        };
                    }
                }
                
                console.log('모든 패턴 매칭 실패');
                return null;
                
            } catch (error) {
                console.error('바코드 파싱 오류:', error);
                return null;
            }
        }

        // 바코드 스캔 시뮬레이션
        function scanBarcode() {
            const input = document.getElementById('barcodeInput');
            const barcode = input.value.trim();
            
            if (barcode) {
                handleBarcodeScan(barcode);
            } else {
                showNotification('바코드를 입력하거나 스캔하세요.', 'warning');
            }
        }

        // 스캔 초기화
        async function clearScan() {
            if (!selectedContainer) {
                scannedUniqueCodes.clear();
                containerParts.forEach(part => {
                    part.scannedQuantity = 0;
                });
                renderPartsList();
                updateProgress();
                document.getElementById('barcodeInput').value = '';
                showNotification('스캔이 초기화되었습니다.', 'info');
                return;
            }
            
            // 컨테이너가 선택된 경우, DB의 PENDING 상태 레코드도 삭제
            try {
                if (supabase && selectedContainer?.arn_number) {
                    // 현재 컨테이너의 PENDING 상태 고유번호 삭제
                    const { error: deleteError } = await supabase
                        .from('scanned_unique_codes')
                        .delete()
                        .eq('arn_number', selectedContainer.arn_number)
                        .eq('status', 'PENDING');
                    
                    if (deleteError) {
                        console.warn('PENDING 상태 고유번호 삭제 오류:', deleteError);
                    } else {
                        console.log('PENDING 상태 고유번호 삭제 완료');
                    }
                }
            } catch (error) {
                console.error('스캔 초기화 중 DB 오류:', error);
            }
            
            scannedUniqueCodes.clear(); // 고유코드 목록 초기화
            
            // 스캔된 수량도 초기화
            containerParts.forEach(part => {
                part.scannedQuantity = 0;
                part.scannedUniqueCodes = []; // 파트별 고유번호 배열도 초기화
            });
            
            renderPartsList();
            updateProgress();
            const barcodeInput = document.getElementById('barcodeInput');
            if (barcodeInput) {
                barcodeInput.value = '';
                setTimeout(() => {
                    barcodeInput.focus();
                    barcodeInput.select();
                }, 100);
            }
            showNotification('스캔이 초기화되었습니다.', 'info');
        }

        // 입고 저장
        async function confirmInbound() {
            console.log('=== 입고 저장 함수 시작 ===');
            console.log('selectedContainer:', selectedContainer);
            console.log('containerParts:', containerParts);
            
            if (!selectedContainer) {
                console.error('컨테이너가 선택되지 않음');
                showNotification('컨테이너가 선택되지 않았습니다.', 'error');
                return;
            }

            // 모든 파트의 스캔 수량이 등록수량과 정확히 일치하는지 확인
            const partsWithMismatch = containerParts.filter(part => part.scannedQuantity !== part.quantity);
            console.log('파트별 스캔 상태:', containerParts.map(p => ({part: p.part_number, scanned: p.scannedQuantity, required: p.quantity, match: p.scannedQuantity === p.quantity})));
            
            if (partsWithMismatch.length > 0) {
                console.error('수량 불일치 파트 발견:', partsWithMismatch);
                const mismatchDetails = partsWithMismatch.map(p => {
                    const diff = p.scannedQuantity - p.quantity;
                    const status = diff > 0 ? `+${diff}개 초과` : `${Math.abs(diff)}개 부족`;
                    return `${p.part_number}: 등록 ${p.quantity}개, 스캔 ${p.scannedQuantity}개 (${status})`;
                }).join('\n');
                
                showNotification(`수량이 일치하지 않습니다:\n${mismatchDetails}`, 'error');
                return;
            }
            
            const allPartsCompleted = containerParts.every(part => part.scannedQuantity === part.quantity);
            if (!allPartsCompleted) {
                console.error('모든 파트의 수량이 확인되지 않음');
                showNotification('모든 파트의 수량을 정확히 확인해야 합니다.', 'error');
                return;
            }

            try {
                console.log('입고 확정 시작:', selectedContainer);
                const today = new Date().toISOString().split('T')[0];
                console.log('오늘 날짜:', today);
                
                // 각 파트별로 inventory 테이블 업데이트 및 거래 내역 기록
                for (const part of containerParts) {
                    console.log('=== 파트 처리 시작 ===');
                    console.log('파트 정보:', part);
                    console.log('파트 번호:', part.part_number, '수량:', part.quantity);
                    
                    // 1. inventory 테이블에서 현재 재고 조회 (관리자모드와 동일)
                    console.log('재고 조회 시작:', part.part_number);
                    const { data: inventoryData, error: inventoryError } = await supabase
                        .from('inventory')
                        .select('part_number, current_stock, status, last_updated')
                        .eq('part_number', part.part_number)
                        .maybeSingle();

                    console.log('재고 조회 결과:', { data: inventoryData, error: inventoryError });

                    if (inventoryError) {
                        console.warn(`파트 ${part.part_number} 재고 조회 오류:`, inventoryError);
                        // 조회 오류가 있어도 새로 생성하도록 진행
                    }

                    // 2. inventory 테이블 업데이트 또는 생성 (관리자모드와 동일)
                    if (inventoryData && inventoryData.part_number) {
                        // 기존 재고가 있으면 수량 증가
                        const newStock = (inventoryData.current_stock || 0) + part.quantity;
                        console.log('기존 재고 업데이트:', part.part_number, `${inventoryData.current_stock} → ${newStock}`);
                        
                        const { error: updateError } = await supabase
                            .from('inventory')
                            .update({
                                current_stock: newStock,
                                last_updated: new Date().toISOString()
                            })
                            .eq('part_number', part.part_number);

                        if (updateError) {
                            console.error(`파트 ${part.part_number} 재고 업데이트 실패:`, updateError);
                            showNotification(`재고 업데이트 오류: ${updateError.message}`, 'error');
                            throw updateError;
                        }
                    } else {
                        // 기존 재고가 없으면 새로 생성
                        console.log('새 재고 생성:', part.part_number, part.quantity);
                        
                        const { error: insertError } = await supabase
                            .from('inventory')
                            .insert({
                                part_number: part.part_number,
                                current_stock: part.quantity,
                                status: 'in_stock',
                                last_updated: new Date().toISOString()
                            });

                        if (insertError) {
                            console.error(`파트 ${part.part_number} 재고 생성 실패:`, insertError);
                            showNotification(`재고 생성 오류: ${insertError.message}`, 'error');
                            throw insertError;
                        }
                    }

                    // 3. 거래 내역 기록 (관리자모드와 동일)
                    const transactionDate = today.includes('T') ? today.split('T')[0] : today;
                    const finalStock = inventoryData ? (inventoryData.current_stock || 0) + part.quantity : part.quantity;
                    
                    const transactionData = {
                        transaction_date: transactionDate,
                        part_number: part.part_number,
                        transaction_type: 'INBOUND',
                        quantity: part.quantity,
                        reference_id: selectedContainer.arn_number,
                        notes: `입고 처리 - ARN: ${selectedContainer.arn_number} (PDA)`
                    };
                    
                    console.log('거래 내역 삽입:', transactionData);
                    const { error: transactionError } = await supabase
                        .from('inventory_transactions')
                        .insert(transactionData);
                    
                    if (transactionError) {
                        console.error(`파트 ${part.part_number} 거래 내역 기록 실패:`, transactionError);
                        showNotification(`거래 내역 삽입 오류: ${transactionError.message}`, 'error');
                        throw transactionError;
                    }
                    
                    console.log(`파트 ${part.part_number} 거래 내역 기록 완료`);
                }
                
                // 4. 컨테이너 상태를 COMPLETED로 변경
                console.log('컨테이너 상태 업데이트:', selectedContainer.arn_number);
                const { error: containerError } = await supabase
                    .from('arn_containers')
                    .update({ 
                        status: 'COMPLETED',
                        inbound_date: today
                    })
                    .eq('arn_number', selectedContainer.arn_number);

                if (containerError) {
                    console.error('컨테이너 상태 업데이트 오류:', containerError);
                    showNotification(`컨테이너 상태 업데이트 오류: ${containerError.message}`, 'error');
                    return;
                }

                // 5. 스캔된 고유번호들의 상태를 COMPLETED로 업데이트 및 입고 날짜 저장
                console.log('고유번호 상태 업데이트 시작:', selectedContainer.arn_number);
                
                // 이 컨테이너에서 스캔된 모든 고유번호를 COMPLETED로 업데이트
                const { error: uniqueCodesUpdateError } = await supabase
                    .from('scanned_unique_codes')
                    .update({
                        status: 'COMPLETED',
                        arn_number: selectedContainer.arn_number,
                        inbound_date: today
                    })
                    .eq('arn_number', selectedContainer.arn_number)
                    .eq('status', 'PENDING');
                
                // arn_number가 null인 경우 (스캔 시점에 컨테이너가 선택되지 않았을 수 있음)
                // part_number로 매칭하여 업데이트
                for (const part of containerParts) {
                    if (part.scannedUniqueCodes && part.scannedUniqueCodes.length > 0) {
                        const { error: partUpdateError } = await supabase
                            .from('scanned_unique_codes')
                            .update({
                                status: 'COMPLETED',
                                arn_number: selectedContainer.arn_number,
                                inbound_date: today
                            })
                            .in('unique_code', part.scannedUniqueCodes)
                            .eq('part_number', part.part_number)
                            .eq('status', 'PENDING');
                        
                        if (partUpdateError) {
                            console.warn(`파트 ${part.part_number} 고유번호 업데이트 오류:`, partUpdateError);
                        }
                    }
                }
                
                if (uniqueCodesUpdateError) {
                    console.warn('고유번호 상태 업데이트 오류 (무시하고 진행):', uniqueCodesUpdateError);
                } else {
                    console.log('고유번호 상태 업데이트 완료');
                }
                
                // 6. 파트 상태를 COMPLETED로 변경
                console.log('파트 상태 업데이트:', selectedContainer.arn_number);
                const { error: partsError } = await supabase
                    .from('arn_parts')
                    .update({ 
                        status: 'COMPLETED'
                    })
                    .eq('arn_number', selectedContainer.arn_number);

                if (partsError) {
                    console.error('파트 상태 업데이트 오류:', partsError);
                    showNotification(`파트 상태 업데이트 오류: ${partsError.message}`, 'error');
                    return;
                }

                const totalQuantity = containerParts.reduce((sum, part) => sum + part.quantity, 0);
                console.log('입고 저장 완료:', {
                    container: selectedContainer.container_number,
                    totalQuantity,
                    partsCount: containerParts.length
                });
                showNotification(`컨테이너 ${selectedContainer.container_number} 입고가 완료되었습니다. (총 수량: ${totalQuantity})`, 'success');
                
                // 페이지 초기화
                setTimeout(() => {
                    resetPage();
                }, 2000);

            } catch (error) {
                console.error('입고 확정 오류:', error);
                showNotification(`입고 저장 중 오류가 발생했습니다: ${error.message}`, 'error');
                
                // 오류 발생 시 현재 컨테이너의 PENDING 상태 고유번호를 삭제하여 재시도 가능하도록 함
                // (사용자가 수동으로 clearScan을 호출할 수도 있지만, 자동으로 정리하는 것이 더 안전)
                try {
                    if (supabase && selectedContainer?.arn_number) {
                        console.log('오류 발생으로 인한 PENDING 상태 고유번호 정리 시작');
                        const { error: cleanupError } = await supabase
                            .from('scanned_unique_codes')
                            .delete()
                            .eq('arn_number', selectedContainer.arn_number)
                            .eq('status', 'PENDING');
                        
                        if (cleanupError) {
                            console.warn('PENDING 상태 고유번호 정리 오류:', cleanupError);
                        } else {
                            console.log('PENDING 상태 고유번호 정리 완료 - 재시도 가능');
                            // 메모리도 초기화
                            scannedUniqueCodes.clear();
                            containerParts.forEach(part => {
                                part.scannedQuantity = 0;
                                part.scannedUniqueCodes = [];
                            });
                            renderPartsList();
                            updateProgress();
                        }
                    }
                } catch (cleanupErr) {
                    console.error('정리 중 오류:', cleanupErr);
                }
            }
        }

        // 입고 취소
        function cancelInbound() {
            scannedUniqueCodes.clear(); // 고유코드 목록도 초기화
            
            // 스캔된 수량도 초기화
            containerParts.forEach(part => {
                part.scannedQuantity = 0;
            });
            
            renderPartsList();
            updateProgress();
            showNotification('입고가 취소되었습니다.', 'info');
        }

        // 페이지 초기화
        function resetPage() {
            selectedContainer = null;
            containerParts = [];
            
            document.getElementById('containerSelect').value = '';
            document.getElementById('scanSection').classList.add('hidden');
            document.getElementById('partsSection').classList.add('hidden');
            document.getElementById('actionButtonsSection').classList.add('hidden');
            document.getElementById('partsList').innerHTML = '';
            
            loadPendingContainers();
        }

        // 알림 표시 (Toast 스타일 - 비차단형)
        function showNotification(message, type = 'info') {
            // 기존 알림이 있으면 제거
            const existingNotification = document.getElementById('toastNotification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Toast 알림 요소 생성
            const notification = document.createElement('div');
            notification.id = 'toastNotification';
            
            // 타입에 따른 색상 설정
            let bgColor = 'bg-blue-500';
            let textColor = 'text-white';
            if (type === 'error' || type === 'danger') {
                bgColor = 'bg-red-500';
            } else if (type === 'success') {
                bgColor = 'bg-green-500';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
            }
            
            notification.className = `fixed top-4 left-1/2 transform -translate-x-1/2 z-50 ${bgColor} ${textColor} px-6 py-4 rounded-lg shadow-lg max-w-md text-center font-semibold text-sm whitespace-pre-line`;
            notification.style.transition = 'opacity 0.3s ease-in-out';
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // 3초 후 자동으로 사라지기
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }, 3000);
            
            // 바코드 입력창 포커스 유지 (alert가 아니므로 포커스가 풀리지 않음)
            const barcodeInput = document.getElementById('barcodeInput');
            const scanSection = document.getElementById('scanSection');
            if (barcodeInput && scanSection && !scanSection.classList.contains('hidden')) {
                // 약간의 지연 후 포커스 유지
                setTimeout(() => {
                    barcodeInput.focus();
                    barcodeInput.select();
                }, 50);
            }
        }

        // 현재 시간 업데이트
        function updateCurrentTime() {
            const now = new Date();
            const timeString = now.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'America/Chicago'
            });
            document.getElementById('currentTime').textContent = timeString;
        }

        // 전역 바코드 입력 버퍼
        let globalBarcodeBuffer = '';
        let globalBarcodeTimer = null;
        const BARCODE_TIMEOUT = 100; // 바코드 입력 완료 판단 시간 (ms)

        // 전역 바코드 입력 상태 표시
        function showGlobalBarcodeStatus() {
            // 상태 표시 요소 생성
            const statusElement = document.createElement('div');
            statusElement.id = 'globalBarcodeStatus';
            statusElement.className = 'fixed top-20 right-4 bg-green-100 border border-green-400 text-green-700 px-3 py-2 rounded-lg text-sm z-50';
            statusElement.innerHTML = '<i class="fas fa-barcode mr-2"></i>전역 바코드 스캔 활성화';
            document.body.appendChild(statusElement);
            
            // 3초 후 자동 숨김
            setTimeout(() => {
                if (statusElement) {
                    statusElement.style.opacity = '0.5';
                }
            }, 3000);
        }

        // 전역 바코드 입력 처리 함수 (개선된 버전 - 키 입력 시 자동 포커스)
        function handleGlobalBarcodeInput(e) {
            // 스캔 섹션이 보이지 않으면 무시
            const scanSection = document.getElementById('scanSection');
            if (!scanSection || scanSection.classList.contains('hidden')) {
                return;
            }
            
            // 바코드 입력창 가져오기
            const barcodeInput = document.getElementById('barcodeInput');
            if (!barcodeInput || barcodeInput.classList.contains('hidden')) {
                return;
            }
            
            const activeElement = document.activeElement;
            
            // Ctrl, Alt, Shift 등의 조합키는 무시 (단, Ctrl+V는 위에서 처리)
            if (e.ctrlKey || e.altKey || e.metaKey) {
                return;
            }
            
            // 특수 키는 무시 (Tab, Escape 등)
            if (e.key.length > 1 && !['Enter', 'Backspace'].includes(e.key)) {
                return;
            }

            // 입력 필드가 포커스되어 있지 않으면 바코드 입력창에 자동 포커스
            if (activeElement !== barcodeInput && 
                activeElement.tagName !== 'INPUT' && 
                activeElement.tagName !== 'SELECT' && 
                activeElement.tagName !== 'TEXTAREA') {
                
                // 일반 문자나 Enter, Backspace 키인 경우에만 처리
                if (e.key.length === 1) {
                    e.preventDefault();
                    barcodeInput.focus();
                    barcodeInput.select();
                    // 키 입력을 바코드 입력창에 직접 추가
                    barcodeInput.value += e.key;
                    // 바코드 패턴 확인 후 자동 스캔
                    checkAndAutoScan(barcodeInput.value);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    barcodeInput.focus();
                    barcodeInput.select();
                    if (barcodeInput.value.trim().length > 0) {
                        scanBarcode();
                    }
                } else if (e.key === 'Backspace') {
                    e.preventDefault();
                    barcodeInput.focus();
                    barcodeInput.select();
                    barcodeInput.value = barcodeInput.value.slice(0, -1);
                }
                return;
            }

            // 바코드 입력창에 포커스가 있으면 일반 동작 (기존 input 이벤트가 처리)
            if (activeElement === barcodeInput) {
                return;
            }

            // Enter 키로 바코드 입력 완료
            if (e.key === 'Enter') {
                e.preventDefault();
                if (barcodeInput.value.trim().length > 0) {
                    scanBarcode();
                }
                return;
            }

            // Backspace 키 처리
            if (e.key === 'Backspace') {
                e.preventDefault();
                barcodeInput.value = barcodeInput.value.slice(0, -1);
                return;
            }

            // 일반 문자 입력
            if (e.key.length === 1) {
                e.preventDefault();
                barcodeInput.value += e.key;
                barcodeInput.focus();
                checkAndAutoScan(barcodeInput.value);
            }
        }
        
        // 바코드 패턴 확인 및 자동 스캔 함수
        function checkAndAutoScan(value) {
            if (!value || value.trim().length === 0) {
                return;
            }
            
            // 타이머 리셋 (연속 입력 중)
            if (globalBarcodeTimer) {
                clearTimeout(globalBarcodeTimer);
            }
            
            // GS1-128 바코드 패턴 확인 (개선된 패턴)
            const isGS1BarcodePattern = /^\[\)>\*06:.*P\d{5}[a-zA-Z]+\d{3,4}.*7Q\d+.*3S[^:]+.*\*EOT$/.test(value);
            
            // 바코드 길이가 30자 이상이거나 GS1 패턴이 맞으면 자동 스캔
            if (value.length >= 30 || (value.length >= 20 && isGS1BarcodePattern)) {
                globalBarcodeTimer = setTimeout(() => {
                    console.log('바코드 입력 완료 (자동):', value);
                    scanBarcode();
                }, 100);
            } else {
                // 일정 시간 입력이 없으면 자동으로 처리
                globalBarcodeTimer = setTimeout(() => {
                    if (value.trim().length > 0) {
                        console.log('바코드 입력 완료 (타이머):', value);
                        scanBarcode();
                    }
                }, BARCODE_TIMEOUT);
            }
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 컨테이너 선택 이벤트
            document.getElementById('containerSelect').addEventListener('change', async function(e) {
                const arnNumber = e.target.value;
                if (arnNumber) {
                    // 컨테이너 정보 로드 (selectedContainer 설정)
                    await loadSelectedContainerInfo(arnNumber);
                    
                    // 컨테이너 파트 로드
                    await loadContainerParts(arnNumber);
                    
                    // UI 섹션 표시
                    document.getElementById('scanSection').classList.remove('hidden');
                    document.getElementById('partsSection').classList.remove('hidden');
                    document.getElementById('actionButtonsSection').classList.remove('hidden');
                    
                    // 바코드 입력창에 포커스 (약간의 지연 후)
                    setTimeout(() => {
                        const barcodeInput = document.getElementById('barcodeInput');
                        if (barcodeInput) {
                            barcodeInput.focus();
                            barcodeInput.select();
                        }
                    }, 300);
                } else {
                    // UI 섹션 숨기기
                    document.getElementById('scanSection').classList.add('hidden');
                    document.getElementById('partsSection').classList.add('hidden');
                    document.getElementById('actionButtonsSection').classList.add('hidden');
                    selectedContainer = null;
                }
            });

            // 전역 키보드 이벤트 리스너 (바코드 스캐너용) - 항상 활성화
            document.addEventListener('keydown', function(e) {
                // 컨테이너 선택 드롭다운이나 버튼에 포커스가 있으면 무시
                const activeElement = document.activeElement;
                if (activeElement && (
                    activeElement.id === 'containerSelect' ||
                    activeElement.closest('button')
                )) {
                    return;
                }
                
                // 스캔 섹션이 보일 때만 전역 바코드 입력 처리
                const scanSection = document.getElementById('scanSection');
                if (scanSection && !scanSection.classList.contains('hidden')) {
                    // Ctrl+V (붙여넣기) 처리
                    if ((e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'V')) {
                        e.preventDefault();
                        e.stopPropagation();
                        const barcodeInput = document.getElementById('barcodeInput');
                        if (barcodeInput) {
                            barcodeInput.focus();
                            barcodeInput.select();
                            // 클립보드에서 붙여넣기 (비동기)
                            navigator.clipboard.readText().then(text => {
                                console.log('클립보드에서 붙여넣기:', text);
                                barcodeInput.value = text;
                                // 바코드가 입력되면 자동 스캔
                                setTimeout(() => {
                                    if (barcodeInput.value.trim().length > 0) {
                                        console.log('붙여넣기 후 자동 스캔:', barcodeInput.value);
                                        scanBarcode();
                                    }
                                }, 150);
                            }).catch(err => {
                                console.error('클립보드 읽기 실패:', err);
                                // 폴백: paste 이벤트가 처리할 것임
                            });
                        }
                        return;
                    }
                    
                    handleGlobalBarcodeInput(e);
                }
            });
            
            // 붙여넣기 이벤트 리스너 추가 (모든 경우 처리)
            document.addEventListener('paste', function(e) {
                const scanSection = document.getElementById('scanSection');
                if (!scanSection || scanSection.classList.contains('hidden')) {
                    return;
                }
                
                const barcodeInput = document.getElementById('barcodeInput');
                if (!barcodeInput || barcodeInput.classList.contains('hidden')) {
                    return;
                }
                
                // 바코드 입력창이 아닌 곳에서 붙여넣기 시 자동으로 바코드 입력창으로 이동
                const activeElement = document.activeElement;
                if (activeElement && activeElement.id !== 'barcodeInput') {
                    e.preventDefault();
                    e.stopPropagation();
                    barcodeInput.focus();
                    barcodeInput.select();
                    
                    // 클립보드 데이터 가져오기
                    const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                    if (pastedText) {
                        console.log('붙여넣기 이벤트:', pastedText);
                        barcodeInput.value = pastedText;
                        // 바코드가 입력되면 자동 스캔
                        setTimeout(() => {
                            if (barcodeInput.value.trim().length > 0) {
                                console.log('붙여넣기 후 자동 스캔:', barcodeInput.value);
                                scanBarcode();
                            }
                        }, 150);
                    }
                }
            });

            // 전역 바코드 입력 상태 표시
            showGlobalBarcodeStatus();

            // 바코드 입력 이벤트
            document.getElementById('barcodeInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    scanBarcode();
                }
            });

            // 바코드 입력 필드 포커스
            document.getElementById('barcodeInput').addEventListener('focus', function() {
                this.select();
            });

            // visibilitychange 이벤트에서 자동 포커스 비활성화 (깜빡임 방지)

            // 자동 엔터키 처리 (바코드 스캐너용)
            let barcodeInputTimer = null;
            document.getElementById('barcodeInput').addEventListener('input', function(e) {
                const input = e.target;
                const value = input.value;
                
                // 이전 타이머 클리어
                if (barcodeInputTimer) {
                    clearTimeout(barcodeInputTimer);
                }
                
                // GS1-128 바코드 패턴 확인 (소문자 l도 포함)
                const isGS1BarcodePattern = /^[)>*].*P\d{5}[a-zA-Z]\d{4}.*7Q\d+.*3SP\d+.*\*EOT$/.test(value);
                
                // 바코드 길이가 30자 이상이거나 GS1 패턴이 맞으면 자동 엔터
                if (value.length >= 30 || (value.length >= 20 && isGS1BarcodePattern)) {
                    barcodeInputTimer = setTimeout(() => {
                        // 엔터키 이벤트 시뮬레이션
                        const enterEvent = new KeyboardEvent('keypress', {
                            key: 'Enter',
                            code: 'Enter',
                            keyCode: 13,
                            which: 13,
                            bubbles: true,
                            cancelable: true
                        });
                        input.dispatchEvent(enterEvent);
                    }, 50);
                }
            });

            // 포커스 유지 기능 비활성화 (깜빡임 방지)
            // 자동 포커스는 바코드 스캔 후에만 설정
        }

        // 선택된 컨테이너 정보 로드 (간소화 - selectedContainer만 설정)
        async function loadSelectedContainerInfo(arnNumber) {
            if (!supabase) return;

            try {
                const { data: container, error } = await supabase
                    .from('arn_containers')
                    .select('*')
                    .eq('arn_number', arnNumber)
                    .single();

                if (error) {
                    console.error('컨테이너 정보 로드 오류:', error);
                    return;
                }

                selectedContainer = container;
            } catch (error) {
                console.error('컨테이너 정보 로드 오류:', error);
            }
        }

        // 페이지 새로고침 함수
        function refreshPage() {
            // 페이지 새로고침
            window.location.reload();
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', function() {
            // Supabase 초기화
            if (initializeSupabase()) {
                loadPendingContainers();
            }
            
            // 이벤트 리스너 설정
            setupEventListeners();
            
            // 시간 업데이트 시작
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
        });

        // 터치 이벤트 최적화
        document.addEventListener('touchstart', function() {}, {passive: true});
        document.addEventListener('touchmove', function() {}, {passive: true});
    </script>
</body>
</html> 